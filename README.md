# **avito internship assignment fall `25**

1. Код сервиса находится в ветке `main`
2. Команды для запуска и тестирования предоставлены в [Makefile](./Makefile)
3. Вопросы и мои решения по ходу реализации - ниже в этом файле

---

## **быстрый старт**
Выполните `docker-compose up` в терминале или из [Makefile](./Makefile).

### **.env.example**
[docker-compose.yaml](./docker-compose.yaml) использует переменные окружения, но, для простоты демонстрации, все они имеют default значения. 
В рамках демо в `.env` нет необходимости, но `.env.example` в любом случае предоставлен в корне проекта и заданные значения будут использованы корректно. 

---
## тестирование
Команды для запуска тестов так же находятся в [Makefile](./Makefile)
* юнит-тесты для сервисов домена.
* интеграционные тесты для инфраструктуры Postgres

Защищенные эндпоинты требуют передачи JWT в заголовках запросов. 
В [Makefile](./Makefile) предоставлены простые команды для генерации токенов для тестирования и демонстрации.

---

## **выполненные доп. задания**

1. настройки линтеров с хуками находятся в [.golangci.yml](./.golangci.yml), [lefthook.yml](./lefthook.yml)
2. добавлен эндпоинт статистики `/stats/assignments` и его документация в [openapi.yaml](./api/openapi.yaml)

---

## вопросы и решения, возникавшие в ходе реализации

**API**

* Метод `setIsActive` использует POST вместо PUT. Не критично для реализации, но логичнее было бы PUT. Решила оставить как есть.
* Эндпоинт `/users/setIsActive` не защищен. Возможно это ошибка, но я решила не менять спецификацию здесь.
* В исходном API не хватало обработки ошибок 400 и 500. Добавила 500 ко всем эндпоинтам и 400 к POST. Иначе в некоторых ситуациях пришлось бы возвращать нелогичные коды ответа.
* Флаг `needMoreReviewers` упомянут в условии задания, но отсутствует в спецификации API. Игнорирую.

**бизнес-логика**

1. **Пользователь может быть в нескольких командах?**

   * Пусть нет — пользователь находится одновременно только в одной команде.

2. **Reassign PR при 0 ревьюверов?**

   * `oldUserID` обязателен, поэтому reassign всегда происходит на существующего пользователя команды. Дополнительной логики не придумывала.

3. **Пользователь может быть добавлен в новую команду, будучи в старой?**

   * Удаляется из старой команды; одновременно в двух командах не находится. 

4. **Перевод пользователя в другую команду с активным PR?**

   * Пусть PR сначала должен быть смержен, затем пользователь может перейти в новую команду. Не придумываем логику переназначения для такой ситуации - reassign остается подконтрольной операцией
